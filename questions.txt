BÀI TEST ĐÁNH GIÁ NĂNG LỰC LẬP TRÌNH CHO SINH VIÊN NGÀNH COMPUTER SCIENCE 
PHẦN I: CÂU HỎI LÝ THUYẾT (8 câu) 
Câu 1: Độ phức tạp thuật toán Câu hỏi: Độ phức tạp thời gian của thuật toán tìm kiếm nhị phân(Binary Search) là: A. O(1) B. O(n) C. O(log n) D. O(n log n) 
Câu 2: Cấu trúc dữ liệu Câu hỏi: Cấu trúc dữ liệu nào nên được sử dụng khi cần thực hiện các hoạt động "Last-In-First-Out" (LIFO)? A. Queue B. Stack C. Linked List D. Binary Tree 
Câu 3: Nguyên tắc lập trình Câu hỏi: Nguyên tắc DRY trong lập trình có nghĩa là: A. Don't Repeat Yourself B. Data Redundancy Yield C. Debug Rigorously Yourself D. Define Resources Yearly 
Câu 4: Lập trình hướng đối tượng Câu hỏi: Đâu KHÔNG phải là một trong bốn nguyên tắc cơ bản của lập trình hướng đối tượng? A. Tính kế thừa (Inheritance) B. Tính bao đóng (Encapsulation) C. ính đa hình (Polymorphism) D. Tính tuần tự (Sequentiality) 
Câu 5: Xử lý lỗi Câu hỏi: Đúng hay Sai: Exception handling (xử lý ngoại lệ) là một phương pháp để xử lý lỗi syntax trong quá trình biên dịch 
Câu 6: Thuật toán Câu hỏi: Thuật toán sắp xếp nào sau đây có độ phức tạp thời gian trường hợp tệ nhất là O(n²)? A. Merge Sort B. Quick Sort C. Heap Sort D. Tất cả đều đúng 
Câu 7: Kiểu dữ liệu và cấu trúc dữ liệu Câu hỏi: Hash table sử dụng cơ chế nào để lưu trữ và truy xuất dữ liệu? A. Indexing B. Hashing function C. Sequential searching D. Binary search 
Câu 8: Nguyên tắc thiết kế phần mềm Câu hỏi: Nguyên tắc "SOLID" trong thiết kế phần mềm hướng đối tượng bao gồm những nguyên tắc nào? Chọn đáp án đúng. A. Single responsibility, Open-clo sed, Liskov substitution, Interface segregation, Dependency inversion B. Structured progr amming, Object-oriented design, Logical flow, Iterative development, Data abstraction C. Syn tax checking, Optimization, Logic verification, Integrated testing, Documentation D. Securi ty, Optimization, Logical design, Inheritance, Debugging 
 PHẦN II: CÂU HỎI THỰC HÀNH (12 câu) 
Câu 9: Xử lý mảng/danh sách Câu hỏi: Viết một thuật toán  để tìm phần tử lớn thứ hai trong một mảng số nguyên không sắp xếp. Không được sắp xếp mản g. 
Câu 10: Xử lý chuỗi Câu hỏi: Viết thuật toán để kiểm tra một chuỗi có phải là palindrome hay không (đọc xuôi ngược đều giống nhau), không phân biệt hoa thường và bỏ qua các ký tự không phải chữ cái. 
Câu 11: Đệ quy Câu hỏi: Viết hàm đệ quy để tính số Fibonacci thứ n. Sau đó, thảo luận về nhược điểm của giải pháp đệ quy này và đề xuất một phương pháp cải tiến. 
Câu 12: Thuật toán tìm kiếm Câu hỏi: Phân tích và viết thuật toán tìm kiếm nhị phân (Binary Search). Nêu rõ điều kiện tiên quyết và độ phức tạp của thuật toán. 
Câu 13: Sửa lỗi Câu hỏi: Đoạn code sau đây có lỗi logic. Hãy tìm và sửa lỗi: function isPrime(n): if n <= 1: return false if n <= 3: return true if n % 2 == 0: return false i = 3 while i < n: if n % i == 0: return false i = i + 2 return true 
Câu 14: Lập trình hướng đối tượng Câu hỏi: Thiết kế một hệ thống quản lý thư viện đơn giản sử dụng các nguyên tắc OOP. Hãy xác định các lớp, mối quan hệ giữa chúng và các phương thức chính. 
Câu 15: Xử lý ngoại lệ Câu hỏi: Viết pseudocode để xử lý các ngoại lệ trong một hàm chia hai số, bao gồm xử lý trường hợp chia cho 0 và kiểm tra đầu vào không phải số. 
Câu 16: Tối ưu hóa code Câu hỏi: Đoạn code sau đây tính tổng các số chẵn trong một mảng. Hãy tối ưu hóa nó và giải thích sự cải tiến. function sumEvenNumbers(array): sum = 0 for i from 0 to length(array)-1: current = array[i] if current % 2 == 0: isEven = true else: isEven = false if isEven == true: sum = sum + current return sum 
Câu 17: Stack và Queue Câu hỏi: Viết một thuật toán để kiểm tra dấu ngoặc trong một biểu thức có cân bằng hay không. Ví dụ: "{[()]}" là cân bằng, "{[(]}" không cân bằng. 
Câu 18: Xử lý file Câu hỏi: Mô tả thuật toán để đọc một file text, đếm số lần xuất hiện của mỗi từ và xuất kết quả ra file mới, sắp xếp theo tần suất giảm dần. 
Câu 19: Phân tích thuật toán Câu hỏi: Phân tích độ phức tạp về thời gian và không gian của thuật toán sau: function mystery(arr, n): if n <= 0: return 0 result = 0 for i from 0 to n-1: for j from i to n-1: result += arr[i] * arr[j] return result 
Câu 20: Bài tập tổng hợp Câu hỏi: Viết thuật toán để tìm đường đi ngắn nhất trong một ma trận từ góc trên bên trái đến góc dưới bên phải. Chỉ được di chuyển xuống hoặc sang phải. Mỗi ô chứa một giá trị chi phí khi đi qua ô đó.